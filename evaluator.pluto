-- @pluto_warnings enable-non-portable-bytecode

local function readfile(path)
	local f <close> = io.open(path, "rb")
	return f:read("*a")
end

local json = require "pluto:json"

local function optimise_public_export(data)
	local optimised = {}
	for data as item do
		optimised[item.uniqueName] = item
	end
	return optimised
end

local ExportWarframes = optimise_public_export(json.decode(readfile("data/ExportWarframes_en.json")).ExportWarframes)
local ExportWeapons = optimise_public_export(json.decode(readfile("data/ExportWeapons_en.json")).ExportWeapons)
local overframe_mods = json.decode(readfile("data/overframe_mods.json"))

local function add_archon_shard(name, upgrade, operation, value)
	name = "/Lotus/Upgrades/Invigorations/ArchonCrystalUpgrades/"..name
	overframe_mods[name] = { data = { Upgrades = { { UpgradeType = upgrade, OperationType = operation, Value = value } } } }
	overframe_mods[name.."Mythic"] = { data = { Upgrades = { { UpgradeType = upgrade, OperationType = operation, Value = value * 1.5 } } } }
end

add_archon_shard("ArchonCrystalUpgradeWarframeHealthMax", "AVATAR_HEALTH_MAX", "ADD", 150)

local function get_num_mods_from_set(mods, set)
	local n = 0
	for mods as mod do
		if overframe_mods[mod.name].data.ModSet == set then
			++n
		end
	end
	return n
end

local function stat_addOperation(stat, type, value)
	if type == "ADD_BASE" then
		stat.base += value
	elseif type == "ADD" then
		stat.add = (stat.add or 0) + value
	else
		assert(type == "STACKING_MULTIPLY")
		stat.stacking_multiply_base = (stat.stacking_multiply_base or 1) + value
	end
end

local function stat_addConditional(stat, conditional)
	if not stat.conditionals then
		stat.conditionals = {}
	end
	stat.conditionals[#stat.conditionals + 1] = conditional
end

local function stat_applyConditionals(stat, to_apply)
	local stacking_multiply_carry = stat.stacking_multiply_base or 1
	if stat.conditionals then
		for stat.conditionals as conditional do
			if to_apply[conditional.type] ~= nil then
				stacking_multiply_carry += conditional.value * to_apply[conditional.type]
			end
		end
	end
	return stat.base * stacking_multiply_carry + (stat.add or 0)
end

local function gear_getStat(gear, upgradeType): ?table
	return switch upgradeType do
		case "AVATAR_HEALTH_MAX" -> gear.health
		case "AVATAR_ARMOUR" -> gear.armor
		case "WEAPON_CRIT_CHANCE" -> gear.crit_chance
	end
end

local function gear_applyMod(gear, mod, value_multiplier)
	if mod.ConditionalUpgrades then
		for mod.Upgrades as upgrade do
			if stat := gear_getStat(gear, upgrade.UpgradeType) then
				stat_addConditional(stat, {
					type = mod.ConditionalUpgrades[1],
					max_stacks = mod.MaxConditionalStacks,
					operation = upgrade.OperationType,
					value = upgrade.Value * value_multiplier,
				})
			end
		end
	else
		for mod.Upgrades as upgrade do
			if stat := gear_getStat(gear, upgrade.UpgradeType) then
				if upgrade.ValidModifiers and #upgrade.ValidModifiers ~= 0 then
					stat_addConditional(stat, {
						type = upgrade.ValidModifiers[1],
						max_stacks = 1,
						operation = upgrade.OperationType,
						value = upgrade.Value * value_multiplier
					})
				elseif upgrade.SymbolFilter and upgrade.SymbolFilter ~= "" then
					if upgrade.SymbolFilter ~= "CC_SLIDING_PVP" then
						stat_addConditional(stat, {
							type = upgrade.SymbolFilter,
							max_stacks = 1,
							operation = upgrade.OperationType,
							value = upgrade.Value * value_multiplier
						})
					end
				else
					stat_addOperation(stat, upgrade.OperationType, upgrade.Value * value_multiplier)
				end
			end
		end
	end
end

export function parse_build(build)
	local eval = {}
	if build.powersuit then
		local pe_data = ExportWarframes[build.powersuit.name]
		eval.powersuit = {
			health = { base = pe_data.health },
			shield = { base = pe_data.shield },
			armor = { base = pe_data.armor },
			power = { base = pe_data.power },
		}

		local rank = build.powersuit.rank or 30
		switch pe_data.parentName do
			case "/Lotus/Powersuits/Sandman/SandmanBaseSuit": -- Inaros
			case "/Lotus/Powersuits/Devourer/DevourerBaseSuit": -- Grendel
				eval.powersuit.health.base += (rank + 2) // 3 * 10
				eval.powersuit.health.base += (rank + 1) // 3 * 10
				eval.powersuit.power.base += rank // 3 * 5
				break

			case "/Lotus/Powersuits/Infestation/InfestationBaseSuit": -- Nidus
				eval.powersuit.health.base += (rank + 2) // 3 * 10
				eval.powersuit.armor.base += (rank + 1) // 3 * 10
				eval.powersuit.power.base += rank // 3 * 5
				break

			case "/Lotus/Powersuits/PaxDuviricus/PaxDuviricusBaseSuit": -- Kullervo
				eval.powersuit.health.base += (rank + 2) // 3 * 20
				eval.powersuit.armor.base += (rank + 1) // 3 * 10
				eval.powersuit.power.base += rank // 3 * 5
				break

			case "/Lotus/Powersuits/IronFrame/IronFrameBaseSuit": -- Hildryn
				eval.powersuit.health.base += (rank + 2) // 3 * 10
				eval.powersuit.shield.base += (rank + 1) // 3 * 25
				eval.powersuit.shield.base += rank // 3 * 25
				break

			case "/Lotus/Powersuits/BrokenFrame/BrokenFrameBaseSuit": -- Xaku
				eval.powersuit.health.base += (rank + 2) // 3 * 9
				eval.powersuit.shield.base += (rank + 1) // 3 * 9
				eval.powersuit.power.base += rank // 3 * 7
				break

			case "/Lotus/Powersuits/Alchemist/AlchemistBaseSuit": -- Lavos
				eval.powersuit.health.base += (rank + 2) // 3 * 20
				eval.powersuit.shield.base += (rank + 1) // 3 * 10
				eval.powersuit.armor.base += rank // 3 * 10
				break

			case "/Lotus/Powersuits/Berserker/BerserkerBaseSuit": -- Valkyr
				eval.powersuit.health.base += (rank + 2) // 3 * 10
				eval.powersuit.shield.base += (rank + 1) // 3 * 5
				eval.powersuit.power.base += rank // 3 * 5
				break

			case "/Lotus/Powersuits/Pacifist/PacifistBaseSuit": -- Baruuk
			case "/Lotus/Powersuits/Garuda/GarudaBaseSuit": -- Garuda
			case "/Lotus/Powersuits/Wisp/WispBaseSuit": -- Wisp
			case "/Lotus/Powersuits/Yareli/YareliBaseSuit": -- Yareli
				eval.powersuit.health.base += (rank + 2) // 3 * 10
				eval.powersuit.shield.base += (rank + 1) // 3 * 10
				eval.powersuit.power.base += rank // 3 * 10
				break

			default:
				eval.powersuit.health.base += (rank + 2) // 3 * 10
				eval.powersuit.shield.base += (rank + 1) // 3 * 10
				eval.powersuit.power.base += rank // 3 * 5
		end

		if build.powersuit.mods then
			for build.powersuit.mods as mod do
				local mod_data = overframe_mods[mod.name].data
				local set_bonus = 1
				if mod_data.ModSetValues then
					local n = get_num_mods_from_set(build.powersuit.mods, mod_data.ModSet)
					set_bonus += mod_data.ModSetValues[n - 1]
				end
				gear_applyMod(eval.powersuit, mod_data, ((mod.rank or 0) + 1) * set_bonus)
			end
		end
	end
	if build.melee then
		local pe_data = ExportWeapons[build.melee.name]
		eval.melee = {
			crit_chance = { base = pe_data.criticalChance },
		}
		for build.melee.mods as mod do
			gear_applyMod(eval.melee, overframe_mods[mod.name].data, (mod.rank or 0) + 1)
		end
	end
	return eval
end

export function build_getConditionals(build)
	local conditionals = {}
	for build as gear do
		for gear as stat do
			if stat.conditionals then
				for stat.conditionals as conditional do
					if not conditionals[conditional.type] then
						conditionals[conditional.type] = {
							max_stacks = conditional.max_stacks
						}
					end
				end
			end
		end
	end
	return conditionals
end

export function build_applyConditionals(build, to_apply)
	local flat_build = {}
	for gear_name, gear in build do
		flat_build[gear_name] = {}
		for stat_name, stat in gear do
			flat_build[gear_name][stat_name] = stat_applyConditionals(stat, to_apply)
		end
	end
	return flat_build
end

export function build_applyNoConditionals(build)
	return build_applyConditionals(build, {})
end

export function build_applyAllConditionals(build)
	local to_apply = {}
	for conditional_type, conditional in build_getConditionals(build) do
		to_apply[conditional_type] = conditional.max_stacks
	end
	return build_applyConditionals(build, to_apply)
end

export function evaluate_build(build)
	return build_applyNoConditionals(parse_build(build))
end

export function armor_to_damage_reduction(armor)
	return armor / (armor + 300)
end

export function calculate_effective_health(health, damage_reduction)
	return health / (1 - damage_reduction)
end
