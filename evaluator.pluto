-- @pluto_warnings enable-non-portable-bytecode

if not ExportWarframes then
	ExportWarframes = dofile("data/ExportWarframes_en.json.lua")
end
if not ExportWeapons then
	ExportWeapons = dofile("data/ExportWeapons_en.json.lua")
end
if not overframe_mods then
	overframe_mods = dofile("data/overframe_mods.json.lua")
end
if not overframe_modsets then
	overframe_modsets = dofile("data/overframe_modsets.json.lua")
end

local function add_archon_shard(name, upgrade, operation, value)
	name = "/Lotus/Upgrades/Invigorations/ArchonCrystalUpgrades/"..name
	overframe_mods[name] = { data = { Upgrades = { { UpgradeType = upgrade, OperationType = operation, Value = value } } } }
	overframe_mods[name.."Mythic"] = { data = { Upgrades = { { UpgradeType = upgrade, OperationType = operation, Value = value * 1.5 } } } }
end

add_archon_shard("ArchonCrystalUpgradeWarframeHealthMax", "AVATAR_HEALTH_MAX", "ADD", 150)

local function get_num_mods_from_set(mods, set)
	local n = 0
	for pairs(mods) as mod do
		if (overframe_mods[mod.name] or error("Unknown mod: "..mod.name)).data.ModSet == set then
			++n
		end
	end
	return n
end

local function stat_addOperation(stat, type, value)
	if type == "ADD_BASE" then
		stat.base += value
	elseif type == "ADD" then
		stat.add = (stat.add or 0) + value
	else
		assert(type == "STACKING_MULTIPLY")
		stat.stacking_multiply_base = (stat.stacking_multiply_base or 1) + value
	end
end

local function stat_addConditional(stat, conditional)
	if not stat.conditionals then
		stat.conditionals = {}
	end

	if (conditional.proc_chance and conditional.proc_chance ~= 1)
		or (conditional.max_stacks and conditional.max_stacks ~= 1 and conditional.type ~= "/Lotus/Upgrades/CosmeticEnhancers/Offensive/OnComboTierCondition")
	then
		conditional.name = conditional.source
	else
		conditional.name = conditional.type
	end

	stat.conditionals[#stat.conditionals + 1] = conditional
end

local function stat_getValue(stat)
	return stat.base * (stat.stacking_multiply_base or 1) + (stat.add or 0)
end

local function stat_applyConditionals(stat, to_apply)
	local tmp = {
		base = stat.base,
		stacking_multiply_base = stat.stacking_multiply_base,
		add = stat.add,
	}
	if stat.conditionals then
		for pairs(stat.conditionals) as conditional do
			if to_apply[conditional.name] ~= nil then
				stat_addOperation(tmp, conditional.operation, conditional.value * to_apply[conditional.name])
			end
		end
	end
	return stat_getValue(tmp)
end

local function upgrade_type_to_gear_name(upgradeType): ?string
	return switch upgradeType do
		case "WEAPON_MELEE_DAMAGE" -> "melee"
		case "WEAPON_MELEE_COMBO_DURATION_BONUS" -> "melee"
	end
end

local function valid_type_to_gear_name(validType): ?string
	return switch validType do
		case "/Lotus/Weapons/Tenno/LotusLongGun" -> "primary"
		case "/Lotus/Weapons/Tenno/LotusPistol" -> "secondary"
		case "/Lotus/Weapons/Tenno/Melee/PlayerMeleeWeapon" -> "melee"
	end
end

local function gear_getStats(gear, upgrade): table
	return switch upgrade.UpgradeType do
		case "AVATAR_HEALTH_MAX" -> { "health" }
		case "AVATAR_ARMOUR" -> { "armor" }
		case "AVATAR_POWER_MAX" -> { "power" }
		case "AVATAR_ABILITY_DURATION" -> { "ability_duration" }
		case "AVATAR_ABILITY_EFFICIENCY" -> { "ability_efficiency" }
		case "AVATAR_ABILITY_RANGE" -> { "ability_range" }
		case "AVATAR_ABILITY_STRENGTH" -> { "ability_strength" }
		case "AVATAR_HEAL_RATE" -> { "heal_rate" }
		case "AVATAR_AURA_STRENGTH" -> { "aura_strength" }
		case "AVATAR_AURA_EFFECTIVENESS_ON_ME" -> { "aura_effectiveness" }
		case "GAMEPLAY_POWER_TO_HEALTH_ON_DEATH" -> { "power_to_health_efficiency" }
		case "WEAPON_DAMAGE_AMOUNT", "WEAPON_MELEE_DAMAGE" -> { "dmg_impact", "dmg_puncture", "dmg_slash", "dmg_heat", "dmg_cold", "dmg_electricity", "dmg_toxin", "dmg_blast", "dmg_radiation", "dmg_gas", "dmg_magnetic", "dmg_viral", "dmg_corrosive" }
		case "WEAPON_PERCENT_BASE_DAMAGE_ADDED" -> switch upgrade.DamageType do
			case "DT_IMPACT" -> { "dmgadd_impact" }
			case "DT_PUNCTURE" -> { "dmgadd_puncture" }
			case "DT_SLASH" -> { "dmgadd_slash" }
			case "DT_FIRE" -> { "dmgadd_heat" }
			case "DT_FREEZE" -> { "dmgadd_cold" }
			case "DT_ELECTRICITY" -> { "dmgadd_electricity" }
			case "DT_POISON" -> { "dmgadd_toxin" }
			case "DT_EXPLOSION" -> { "dmgadd_blast" }
			case "DT_RADIANT" -> { "dmgadd_radiation" }
			case "DT_GAS" -> { "dmgadd_gas" }
			case "DT_MAGNETIC" -> { "dmgadd_magnetic" }
			case "DT_VIRAL" -> { "dmgadd_viral" }
			case "DT_CORROSIVE" -> { "dmgadd_corrosive" }
			default -> --[[print("Silently ignoring WEAPON_PERCENT_BASE_DAMAGE_ADDED with "..upgrade.DamageType) or]] {}
		end
		case "WEAPON_CRIT_CHANCE" -> { "crit_chance" }
		case "WEAPON_FIRE_RATE" -> { "fire_rate" }
		case "WEAPON_MELEE_COMBO_DURATION_BONUS" -> { "combo_duration" }
		default -> --[[print("Silently ignoring "..upgradeType) or]] {}
	end
end

local function fusion_level_to_rank(qa): int
	return switch qa do
		case "QA_VERY_HIGH" -> 10
		case "QA_HIGH" -> 5
		case "QA_MEDIUM" -> 3
		default -> 0
	end
end

export function get_fusion_limit(mod): int
	local mod_data = (overframe_mods[mod] or error("Unknown mod: "..mod)).data
	return mod_data.FusionLimit ? fusion_level_to_rank(mod_data.FusionLimit) : 5
end

local function build_applyMod(build, gear_name: ?string, mod_name, mod, rank = 0, value_multiplier = 1)
	if mod.Upgrades then
		if mod.ConditionalUpgrades then
			for pairs(mod.Upgrades) as upgrade do
				local stats = gear_getStats(build[gear_name], upgrade)
				local applied = false
				for pairs(stats) as stat_name do
					local stat = build[gear_name]?[stat_name]
					if stat then
						applied = true
						stat_addConditional(stat, {
							type = mod.ConditionalUpgrades[1],
							source = mod_name,
							proc_chance = mod.UpgradeChance,
							max_stacks = mod.MaxConditionalStacks,
							operation = upgrade.OperationType,
							value = upgrade.Value * value_multiplier,
						})
					end
				end
				if not applied then
					if upgrade_gear_name := upgrade_type_to_gear_name(upgrade.UpgradeType) or valid_type_to_gear_name(upgrade.ValidType) then
						local upgrade_stats = gear_getStats(build[upgrade_gear_name], upgrade)
						for pairs(upgrade_stats) as upgrade_stat_name do
							if stat := build[upgrade_gear_name]?[upgrade_stat_name] then
								stat_addConditional(stat, {
									type = mod.ConditionalUpgrades[1],
									source = mod_name,
									proc_chance = mod.UpgradeChance,
									max_stacks = mod.MaxConditionalStacks,
									operation = upgrade.OperationType,
									value = upgrade.Value * value_multiplier,
								})
							end
						end
					end
				end
			end
		else
			for pairs(mod.Upgrades) as upgrade do
				local stats = gear_getStats(build[gear_name], upgrade)
				for pairs(stats) as stat_name do
					local stat = build[gear_name]?[stat_name]
					if stat then
						if upgrade.ValidModifiers and #upgrade.ValidModifiers ~= 0 then
							stat_addConditional(stat, {
								type = upgrade.ValidModifiers[1],
								source = mod_name,
								max_stacks = 1,
								operation = upgrade.OperationType,
								value = upgrade.Value * value_multiplier
							})
						elseif upgrade.SymbolFilter and upgrade.SymbolFilter ~= "" then
							if upgrade.SymbolFilter ~= "CC_SLIDING_PVP" then
								stat_addConditional(stat, {
									type = upgrade.SymbolFilter,
									source = mod_name,
									max_stacks = 1,
									operation = upgrade.OperationType,
									value = upgrade.Value * value_multiplier
								})
							end
						else
							stat_addOperation(stat, upgrade.OperationType, upgrade.Value * value_multiplier)
						end
					end
				end
			end
		end
	end
	if mod.ExtraUpgrades and rank >= fusion_level_to_rank(mod.ExtraUpgradeFusionLevel) then
		for pairs(mod.ExtraUpgrades) as upgrade do
			if upgrade.ValidType ~= "" then
				assert(upgrade.ValidType == "/Lotus/Weapons/Tenno/Melee/PlayerMeleeWeapon")
				local stats = gear_getStats(build.melee, upgrade)
				for pairs(stats) as stat_name do
					if stat := build.melee?[stat_name] then
						stat_addOperation(stat, upgrade.OperationType, upgrade.Value)
					end
				end
			else
				local stats = gear_getStats(build[gear_name], upgrade)
				for pairs(stats) as stat_name do
					if stat := build[gear_name][stat_name] then
						stat_addOperation(stat, upgrade.OperationType, upgrade.Value)
					end
				end
			end
		end
	end
	if mod.SubUpgrades then
		for pairs(mod.SubUpgrades) as sub_upgrade do
			if type(sub_upgrade) == "table" then
				build_applyMod(build, gear_name, mod_name, sub_upgrade, rank, value_multiplier)
			end
		end
	end
end

local function init_gear(pe_data)
	return {
		dmg_impact = { base = pe_data.damagePerShot[1] },
		dmg_puncture = { base = pe_data.damagePerShot[2] },
		dmg_slash = { base = pe_data.damagePerShot[3] },
		dmg_heat = { base = pe_data.damagePerShot[4] },
		dmg_cold = { base = pe_data.damagePerShot[5] },
		dmg_electricity = { base = pe_data.damagePerShot[6] },
		dmg_toxin = { base = pe_data.damagePerShot[7] },
		dmg_blast = { base = pe_data.damagePerShot[8] },
		dmg_radiation = { base = pe_data.damagePerShot[9] },
		dmg_gas = { base = pe_data.damagePerShot[10] },
		dmg_magnetic = { base = pe_data.damagePerShot[11] },
		dmg_viral = { base = pe_data.damagePerShot[12] },
		dmg_corrosive = { base = pe_data.damagePerShot[13] },
		dmgadd_impact = { base = 0 },
		dmgadd_puncture = { base = 0 },
		dmgadd_slash = { base = 0 },
		dmgadd_heat = { base = 0 },
		dmgadd_cold = { base = 0 },
		dmgadd_electricity = { base = 0 },
		dmgadd_toxin = { base = 0 },
		dmgadd_blast = { base = 0 },
		dmgadd_radiation = { base = 0 },
		dmgadd_gas = { base = 0 },
		dmgadd_magnetic = { base = 0 },
		dmgadd_viral = { base = 0 },
		dmgadd_corrosive = { base = 0 },
		crit_chance = { base = pe_data.criticalChance },
		fire_rate = { base = pe_data.fireRate },
	}
end

export function parse_build(inbuild)
	local build = {}
	if inbuild.powersuit?.name then
		local pe_data = ExportWarframes[inbuild.powersuit.name] or error("Unknown powersuit: "..inbuild.powersuit.name)
		build.powersuit = {
			health = { base = pe_data.health },
			shield = { base = pe_data.shield },
			armor = { base = pe_data.armor },
			power = { base = pe_data.power },
			ability_duration = { base = 1 },
			ability_efficiency = { base = 1 },
			ability_range = { base = 1 },
			ability_strength = { base = 1, stacking_multiply_base = 1 },
			heal_rate = { base = 0 },
			aura_strength = { base = 1 },
			aura_effectiveness = { base = 1 },
			power_to_health_efficiency = { base = 0 },
		}

		local rank = inbuild.powersuit.rank or 30
		switch pe_data.parentName do
			case "/Lotus/Powersuits/Sandman/SandmanBaseSuit": -- Inaros
			case "/Lotus/Powersuits/Devourer/DevourerBaseSuit": -- Grendel
				build.powersuit.health.base += (rank + 2) // 3 * 10
				build.powersuit.health.base += (rank + 1) // 3 * 10
				build.powersuit.power.base += rank // 3 * 5
				break

			case "/Lotus/Powersuits/Infestation/InfestationBaseSuit": -- Nidus
				build.powersuit.health.base += (rank + 2) // 3 * 10
				build.powersuit.armor.base += (rank + 4) // 6 * 20
				build.powersuit.ability_strength.stacking_multiply_base += (rank + 3) // 6 * 0.03
				build.powersuit.power.base += rank // 6 * 10
				build.powersuit.heal_rate.base = 5
				build.powersuit.heal_rate.base += rank // 6 * 2
				break

			case "/Lotus/Powersuits/PaxDuviricus/PaxDuviricusBaseSuit": -- Kullervo
				build.powersuit.health.base += (rank + 2) // 3 * 20
				build.powersuit.armor.base += (rank + 1) // 3 * 10
				build.powersuit.power.base += rank // 3 * 5
				break

			case "/Lotus/Powersuits/IronFrame/IronFrameBaseSuit": -- Hildryn
				build.powersuit.health.base += (rank + 2) // 3 * 10
				build.powersuit.shield.base += (rank + 1) // 3 * 25
				build.powersuit.shield.base += rank // 3 * 25
				break

			case "/Lotus/Powersuits/BrokenFrame/BrokenFrameBaseSuit": -- Xaku
				build.powersuit.health.base += (rank + 2) // 3 * 9
				build.powersuit.shield.base += (rank + 1) // 3 * 9
				build.powersuit.power.base += rank // 3 * 7
				break

			case "/Lotus/Powersuits/Alchemist/AlchemistBaseSuit": -- Lavos
				build.powersuit.health.base += (rank + 2) // 3 * 20
				build.powersuit.shield.base += (rank + 1) // 3 * 10
				build.powersuit.armor.base += rank // 3 * 10
				break

			case "/Lotus/Powersuits/Berserker/BerserkerBaseSuit": -- Valkyr
				build.powersuit.health.base += (rank + 2) // 3 * 10
				build.powersuit.shield.base += (rank + 1) // 3 * 5
				build.powersuit.power.base += rank // 3 * 5
				break

			case "/Lotus/Powersuits/Pacifist/PacifistBaseSuit": -- Baruuk
			case "/Lotus/Powersuits/Garuda/GarudaBaseSuit": -- Garuda
			case "/Lotus/Powersuits/Wisp/WispBaseSuit": -- Wisp
			case "/Lotus/Powersuits/Yareli/YareliBaseSuit": -- Yareli
				build.powersuit.health.base += (rank + 2) // 3 * 10
				build.powersuit.shield.base += (rank + 1) // 3 * 10
				build.powersuit.power.base += rank // 3 * 10
				break

			default:
				build.powersuit.health.base += (rank + 2) // 3 * 10
				build.powersuit.shield.base += (rank + 1) // 3 * 10
				build.powersuit.power.base += rank // 3 * 5
		end
	end
	if inbuild.primary?.name then
		build.primary = init_gear(ExportWeapons[inbuild.primary.name])
	end
	if inbuild.secondary?.name then
		build.secondary = init_gear(ExportWeapons[inbuild.secondary.name])
	end
	if inbuild.melee?.name then
		local pe_data = ExportWeapons[inbuild.melee.name]
		build.melee = init_gear(pe_data)
		build.melee.combo_duration = { base = pe_data.comboDuration }
	end
	local sets = {}
	if inbuild.powersuit then
		if inbuild.powersuit.mods then
			local aura_mod
			for pairs(inbuild.powersuit.mods) as mod do
				local mod_data = (overframe_mods[mod.name] or error("Unknown mod: "..mod.name)).data
				local set_bonus = 1
				if mod_data.ModSetValues then
					local n = get_num_mods_from_set(inbuild.powersuit.mods, mod_data.ModSet)
					if n > 1 then
						set_bonus += mod_data.ModSetValues[n - 1]
					end
				elseif mod_data.ModSet then
					sets[mod_data.ModSet] = (sets[mod_data.ModSet] or 0) + 1
				end
				local value_multiplier = ((mod.rank or 0) + 1) * set_bonus
				if mod_data.ItemCompatibilityLocTag == "/Lotus/Language/Menu/CategoryAura" then
					-- Save aura mod for later so aura strength can be applied
					aura_mod = { name = mod.name, data = mod_data, rank = mod.rank, mult = value_multiplier }
				else
					build_applyMod(build, "powersuit", mod.name, mod_data, rank, value_multiplier)
				end
			end
			if aura_mod then
				build_applyMod(build, "powersuit", aura_mod.name, aura_mod.data, aura_mod.rank, aura_mod.mult * stat_getValue(build.powersuit.aura_strength) * stat_getValue(build.powersuit.aura_effectiveness))
			end
		end
		if build.powersuit then
			build.powersuit.aura_strength = nil
			build.powersuit.aura_effectiveness = nil
		end
	end
	if inbuild.primary?.mods then
		for pairs(inbuild.primary.mods) as mod do
			local mod_data = (overframe_mods[mod.name] or error("Unknown mod: "..mod.name)).data
			if mod_data.ModSet then
				sets[mod_data.ModSet] = (sets[mod_data.ModSet] or 0) + 1
			end
			build_applyMod(build, "primary", mod.name, mod_data, mod.rank, (mod.rank or 0) + 1)
		end
	end
	if inbuild.secondary?.mods then
		for pairs(inbuild.secondary.mods) as mod do
			local mod_data = (overframe_mods[mod.name] or error("Unknown mod: "..mod.name)).data
			if mod_data.ModSet then
				sets[mod_data.ModSet] = (sets[mod_data.ModSet] or 0) + 1
			end
			build_applyMod(build, "secondary", mod.name, mod_data, mod.rank, (mod.rank or 0) + 1)
		end
	end
	if inbuild.melee?.mods then
		for pairs(inbuild.melee.mods) as mod do
			local mod_data = (overframe_mods[mod.name] or error("Unknown mod: "..mod.name)).data
			local set_bonus = 1
			if mod_data.ModSetValues then
				local n = get_num_mods_from_set(inbuild.melee.mods, mod_data.ModSet)
				if n > 1 then
					set_bonus += mod_data.ModSetValues[n - 1]
				end
			elseif mod_data.ModSet then
				sets[mod_data.ModSet] = (sets[mod_data.ModSet] or 0) + 1
			end
			build_applyMod(build, "melee", mod.name, mod_data, mod.rank, ((mod.rank or 0) + 1) * set_bonus)
		end
	end
	for set, n in pairs(sets) do
		build_applyMod(build, nil, set, overframe_modsets[set].data, n, n)
	end
	return build
end

export function build_getConditionals(build)
	local conditionals = {}
	for pairs(build) as gear do
		for pairs(gear) as stat do
			if stat.conditionals then
				for pairs(stat.conditionals) as conditional do
					if not conditionals[conditional.name] then
						conditionals[conditional.name] = {
							type = conditional.type,
							source = conditional.source,
							proc_chance = conditional.proc_chance or 1,
							max_stacks = conditional.max_stacks or 1
						}
					end
				end
			end
		end
	end
	return conditionals
end

local function finalise_dmg(gear)
	local base_dmg = gear.dmg_impact + gear.dmg_puncture + gear.dmg_slash + gear.dmg_heat + gear.dmg_cold + gear.dmg_electricity + gear.dmg_toxin + gear.dmg_blast + gear.dmg_radiation + gear.dmg_gas + gear.dmg_magnetic + gear.dmg_viral + gear.dmg_corrosive

	if gear.dmgadd_gas ~= 0 then
		gear.dmg_gas += base_dmg * gear.dmgadd_gas
	end
	if gear_dmgadd_impact ~= 0 then
		gear.dmg_impact += base_dmg * gear.dmgadd_impact
	end
	if gear_dmgadd_puncture ~= 0 then
		gear.dmg_puncture += base_dmg * gear.dmgadd_puncture
	end
	if gear_dmgadd_slash ~= 0 then
		gear.dmg_slash += base_dmg * gear.dmgadd_slash
	end
	if gear_dmgadd_heat ~= 0 then
		gear.dmg_heat += base_dmg * gear.dmgadd_heat
	end
	if gear_dmgadd_cold ~= 0 then
		gear.dmg_cold += base_dmg * gear.dmgadd_cold
	end
	if gear_dmgadd_electricity ~= 0 then
		gear.dmg_electricity += base_dmg * gear.dmgadd_electricity
	end
	if gear_dmgadd_toxin ~= 0 then
		gear.dmg_toxin += base_dmg * gear.dmgadd_toxin
	end
	if gear_dmgadd_blast ~= 0 then
		gear.dmg_blast += base_dmg * gear.dmgadd_blast
	end
	if gear_dmgadd_radiation ~= 0 then
		gear.dmg_radiation += base_dmg * gear.dmgadd_radiation
	end
	if gear_dmgadd_gas ~= 0 then
		gear.dmg_gas += base_dmg * gear.dmgadd_gas
	end
	if gear_dmgadd_magnetic ~= 0 then
		gear.dmg_magnetic += base_dmg * gear.dmgadd_magnetic
	end
	if gear_dmgadd_viral ~= 0 then
		gear.dmg_viral += base_dmg * gear.dmgadd_viral
	end
	if gear_dmgadd_corrosive ~= 0 then
		gear.dmg_corrosive += base_dmg * gear.dmgadd_corrosive
	end

	gear.dmgadd_impact = nil
	gear.dmgadd_puncture = nil
	gear.dmgadd_slash = nil
	gear.dmgadd_heat = nil
	gear.dmgadd_cold = nil
	gear.dmgadd_electricity = nil
	gear.dmgadd_toxin = nil
	gear.dmgadd_blast = nil
	gear.dmgadd_radiation = nil
	gear.dmgadd_gas = nil
	gear.dmgadd_magnetic = nil
	gear.dmgadd_viral = nil
	gear.dmgadd_corrosive = nil
end

export function build_applyConditionals(build, to_apply)
	local outbuild = {}
	for gear_name, gear in pairs(build) do
		outbuild[gear_name] = {}
		for stat_name, stat in pairs(gear) do
			outbuild[gear_name][stat_name] = stat_applyConditionals(stat, to_apply)
		end
	end
	if outbuild.powersuit then
		outbuild.powersuit.power_health = outbuild.powersuit.power * outbuild.powersuit.power_to_health_efficiency
		outbuild.powersuit.armor_damage_reduction = outbuild.powersuit.armor / (outbuild.powersuit.armor + 300)
		outbuild.powersuit.effective_health = outbuild.powersuit.health / (1 - outbuild.powersuit.armor_damage_reduction)
		outbuild.powersuit.effective_power_health = outbuild.powersuit.power_health / (1 - outbuild.powersuit.armor_damage_reduction)
		outbuild.powersuit.effective_health_incl_power = outbuild.powersuit.effective_health + outbuild.powersuit.effective_power_health
	end
	if outbuild.primary then
		finalise_dmg(outbuild.primary)
	end
	if outbuild.secondary then
		finalise_dmg(outbuild.secondary)
	end
	if outbuild.melee then
		finalise_dmg(outbuild.melee)
	end
	return outbuild
end

export function build_applyNoConditionals(build)
	return build_applyConditionals(build, {})
end

export function build_applyAllConditionals(build)
	local to_apply = {}
	for conditional_type, conditional in pairs(build_getConditionals(build)) do
		to_apply[conditional_type] = conditional.max_stacks
	end
	return build_applyConditionals(build, to_apply)
end

export function evaluate_build(build)
	return build_applyNoConditionals(parse_build(build))
end

-- Evaluation for damage against enemies (Experimental)

if not enemies then
	local cloned_flesh = {
		impact = -0.25,
		slash = 0.25,
		gas = -0.50,
		heat = 0.25,
		cloned_flesh = 0.75,
	}

	local ferrite_armor = {
		puncture = 0.50,
		slash = -0.15,
		blast = -0.25,
		viral = 0.75,
	}

	enemies = {
		["Lancer"] = {
			base_level = 1,
			health = cloned_flesh,
			armor = ferrite_armor,
			armor_points = 100,
		},
		["Heavy Gunner"] = {
			base_level = 8,
			health = cloned_flesh,
			armor = ferrite_armor,
			armor_points = 500,
		}
	}
end

local function level_scaling_trans(base_level, start, _end, level)
	if level - base_level < start then
		return 0
	end
	if level - base_level > _end then
		return 1
	end
	local T = (level - base_level - start) / (_end - start)
	return 3 * T ^ 2 - 2 * T ^ 3
end

local function enemy_getArmor(enemy, level)
	if level < enemy.base_level then
		level = enemy.base_level
	end
	local old_armor = 1 + 0.005 * (level - enemy.base_level) ^ 1.75
	local new_armor = 1 + 0.40 * (level - enemy.base_level) ^ 0.75
	local armor_mult = old_armor * (1 - level_scaling_trans(enemy.base_level, 70, 80, level)) + new_armor * level_scaling_trans(enemy.base_level, 70, 80, level)
	return enemy.armor_points * armor_mult
end

local function enemy_getEffectiveDamageOfType(enemy, level, damage_type, amount)
	local health_offset = enemy.health[damage_type] or 0
	local armor_offset = enemy.armor[damage_type] or 0
	local armor = enemy_getArmor(enemy, level)
	return amount * (1 + health_offset) * (1 + armor_offset) * 300 / (300 + armor * (1 - armor_offset))
end

export function enemy_getEffectiveDamage(enemy, level, gear)
	return enemy_getEffectiveDamageOfType(enemy, level, "impact", gear.dmg_impact)
		+ enemy_getEffectiveDamageOfType(enemy, level, "puncture", gear.dmg_puncture)
		+ enemy_getEffectiveDamageOfType(enemy, level, "slash", gear.dmg_slash)
		+ enemy_getEffectiveDamageOfType(enemy, level, "heat", gear.dmg_heat)
		+ enemy_getEffectiveDamageOfType(enemy, level, "cold", gear.dmg_cold)
		+ enemy_getEffectiveDamageOfType(enemy, level, "electricity", gear.dmg_electricity)
		+ enemy_getEffectiveDamageOfType(enemy, level, "toxin", gear.dmg_toxin)
		+ enemy_getEffectiveDamageOfType(enemy, level, "blast", gear.dmg_blast)
		+ enemy_getEffectiveDamageOfType(enemy, level, "radiation", gear.dmg_radiation)
		+ enemy_getEffectiveDamageOfType(enemy, level, "gas", gear.dmg_gas)
		+ enemy_getEffectiveDamageOfType(enemy, level, "magnetic", gear.dmg_magnetic)
		+ enemy_getEffectiveDamageOfType(enemy, level, "viral", gear.dmg_viral)
		+ enemy_getEffectiveDamageOfType(enemy, level, "corrosive", gear.dmg_corrosive)
end
