-- @pluto_warnings enable-non-portable-bytecode

if not ExportWarframes then
	ExportWarframes = dofile("data/ExportWarframes_en.json.lua")
end
if not ExportWeapons then
	ExportWeapons = dofile("data/ExportWeapons_en.json.lua")
end
if not overframe_mods then
	overframe_mods = dofile("data/overframe_mods.json.lua")
end
if not overframe_modsets then
	overframe_modsets = dofile("data/overframe_modsets.json.lua")
end

local function add_archon_shard(name, upgrade, operation, value)
	name = "/Lotus/Upgrades/Invigorations/ArchonCrystalUpgrades/"..name
	overframe_mods[name] = { data = { Upgrades = { { UpgradeType = upgrade, OperationType = operation, Value = value } } } }
	overframe_mods[name.."Mythic"] = { data = { Upgrades = { { UpgradeType = upgrade, OperationType = operation, Value = value * 1.5 } } } }
end

add_archon_shard("ArchonCrystalUpgradeWarframeHealthMax", "AVATAR_HEALTH_MAX", "ADD", 150)

local function get_num_mods_from_set(mods, set)
	local n = 0
	for pairs(mods) as mod do
		if (overframe_mods[mod.name] or error("Unknown mod: "..mod.name)).data.ModSet == set then
			++n
		end
	end
	return n
end

local function stat_addOperation(stat, type, value)
	if type == "ADD_BASE" then
		stat.base += value
	elseif type == "ADD" then
		stat.add = (stat.add or 0) + value
	else
		assert(type == "STACKING_MULTIPLY")
		stat.stacking_multiply_base = (stat.stacking_multiply_base or 1) + value
	end
end

local function stat_addConditional(stat, conditional)
	if not stat.conditionals then
		stat.conditionals = {}
	end
	stat.conditionals[#stat.conditionals + 1] = conditional
end

local function stat_getValue(stat)
	return stat.base * (stat.stacking_multiply_base or 1) + (stat.add or 0)
end

local function stat_applyConditionals(stat, to_apply)
	local tmp = {
		base = stat.base,
		stacking_multiply_base = stat.stacking_multiply_base,
		add = stat.add,
	}
	if stat.conditionals then
		for pairs(stat.conditionals) as conditional do
			if to_apply[conditional.type] ~= nil then
				stat_addOperation(tmp, conditional.operation, conditional.value * to_apply[conditional.type])
			end
		end
	end
	return stat_getValue(tmp)
end

local function upgrade_type_to_gear_name(upgradeType): ?string
	return switch upgradeType do
		case "WEAPON_MELEE_DAMAGE" -> "melee"
		case "WEAPON_MELEE_COMBO_DURATION_BONUS" -> "melee"
	end
end

local function valid_type_to_gear_name(validType): ?string
	return switch validType do
		case "/Lotus/Weapons/Tenno/LotusLongGun" -> "primary"
		case "/Lotus/Weapons/Tenno/LotusPistol" -> "secondary"
		case "/Lotus/Weapons/Tenno/Melee/PlayerMeleeWeapon" -> "melee"
	end
end

local function gear_getStats(gear, upgradeType): table
	return switch upgradeType do
		case "AVATAR_HEALTH_MAX" -> { "health" }
		case "AVATAR_ARMOUR" -> { "armor" }
		case "AVATAR_ABILITY_STRENGTH" -> { "ability_strength" }
		case "AVATAR_HEAL_RATE" -> { "heal_rate" }
		case "AVATAR_AURA_STRENGTH" -> { "aura_strength" }
		case "AVATAR_AURA_EFFECTIVENESS_ON_ME" -> { "aura_effectiveness" }
		case "GAMEPLAY_POWER_TO_HEALTH_ON_DEATH" -> { "power_to_health_efficiency" }
		case "WEAPON_DAMAGE_AMOUNT", "WEAPON_MELEE_DAMAGE" -> { "dmg_impact", "dmg_puncture", "dmg_slash", "dmg_heat", "dmg_cold", "dmg_electricity", "dmg_toxin", "dmg_blast", "dmg_radiation", "dmg_gas", "dmg_magnetic", "dmg_viral", "dmg_corrosive" }
		case "WEAPON_CRIT_CHANCE" -> { "crit_chance" }
		case "WEAPON_MELEE_COMBO_DURATION_BONUS" -> { "combo_duration" }
		default -> --[[print("Silently ignoring "..upgradeType) or]] {}
	end
end

local function fusion_level_to_rank(qa): int
	return switch qa do
		case "QA_VERY_HIGH" -> 10
		case "QA_HIGH" -> 5
		case "QA_MEDIUM" -> 3
		default -> 0
	end
end

export function get_fusion_limit(mod): int
	local mod_data = (overframe_mods[mod] or error("Unknown mod: "..mod)).data
	return mod_data.FusionLimit ? fusion_level_to_rank(mod_data.FusionLimit) : 5
end

local function build_applyMod(build, gear_name: ?string, mod, rank = 0, value_multiplier = 1)
	if mod.Upgrades then
		if mod.ConditionalUpgrades then
			for pairs(mod.Upgrades) as upgrade do
				local stats = gear_getStats(build[gear_name], upgrade.UpgradeType)
				local applied = false
				for pairs(stats) as stat_name do
					local stat = build[gear_name]?[stat_name]
					if stat then
						applied = true
						stat_addConditional(stat, {
							type = mod.ConditionalUpgrades[1],
							proc_chance = mod.UpgradeChance or 1,
							max_stacks = mod.MaxConditionalStacks or 1,
							operation = upgrade.OperationType,
							value = upgrade.Value * value_multiplier,
						})
					end
				end
				if not applied then
					if upgrade_gear_name := upgrade_type_to_gear_name(upgrade.UpgradeType) or valid_type_to_gear_name(upgrade.ValidType) then
						local upgrade_stats = gear_getStats(build[upgrade_gear_name], upgrade.UpgradeType)
						for pairs(upgrade_stats) as upgrade_stat_name do
							if stat := build[upgrade_gear_name]?[upgrade_stat_name] then
								stat_addConditional(stat, {
									type = mod.ConditionalUpgrades[1],
									proc_chance = mod.UpgradeChance or 1,
									max_stacks = mod.MaxConditionalStacks or 1,
									operation = upgrade.OperationType,
									value = upgrade.Value * value_multiplier,
								})
							end
						end
					end
				end
			end
		else
			for pairs(mod.Upgrades) as upgrade do
				local stats = gear_getStats(build[gear_name], upgrade.UpgradeType)
				for pairs(stats) as stat_name do
					local stat = build[gear_name]?[stat_name]
					if stat then
						if upgrade.ValidModifiers and #upgrade.ValidModifiers ~= 0 then
							stat_addConditional(stat, {
								type = upgrade.ValidModifiers[1],
								max_stacks = 1,
								operation = upgrade.OperationType,
								value = upgrade.Value * value_multiplier
							})
						elseif upgrade.SymbolFilter and upgrade.SymbolFilter ~= "" then
							if upgrade.SymbolFilter ~= "CC_SLIDING_PVP" then
								stat_addConditional(stat, {
									type = upgrade.SymbolFilter,
									max_stacks = 1,
									operation = upgrade.OperationType,
									value = upgrade.Value * value_multiplier
								})
							end
						else
							stat_addOperation(stat, upgrade.OperationType, upgrade.Value * value_multiplier)
						end
					end
				end
			end
		end
	end
	if mod.ExtraUpgrades and rank >= fusion_level_to_rank(mod.ExtraUpgradeFusionLevel) then
		for pairs(mod.ExtraUpgrades) as upgrade do
			if upgrade.ValidType ~= "" then
				assert(upgrade.ValidType == "/Lotus/Weapons/Tenno/Melee/PlayerMeleeWeapon")
				local stats = gear_getStats(build.melee, upgrade.UpgradeType)
				for pairs(stats) as stat_name do
					if stat := build.melee[stat_name] then
						stat_addOperation(stat, upgrade.OperationType, upgrade.Value)
					end
				end
			else
				local stats = gear_getStats(build[gear_name], upgrade.UpgradeType)
				for pairs(stats) as stat_name do
					if stat := build[gear_name][stat_name] then
						stat_addOperation(stat, upgrade.OperationType, upgrade.Value)
					end
				end
			end
		end
	end
	if mod.SubUpgrades then
		for pairs(mod.SubUpgrades) as sub_upgrade do
			if type(sub_upgrade) == "table" then
				build_applyMod(build, gear_name, sub_upgrade, rank, value_multiplier)
			end
		end
	end
end

export function parse_build(inbuild)
	local build = {}
	if inbuild.powersuit?.name then
		local pe_data = ExportWarframes[inbuild.powersuit.name] or error("Unknown powersuit: "..inbuild.powersuit.name)
		build.powersuit = {
			health = { base = pe_data.health },
			shield = { base = pe_data.shield },
			armor = { base = pe_data.armor },
			power = { base = pe_data.power },
			ability_strength = { base = 1, stacking_multiply_base = 1 },
			heal_rate = { base = 0 },
			aura_strength = { base = 1 },
			aura_effectiveness = { base = 1 },
			power_to_health_efficiency = { base = 0 },
		}

		local rank = inbuild.powersuit.rank or 30
		switch pe_data.parentName do
			case "/Lotus/Powersuits/Sandman/SandmanBaseSuit": -- Inaros
			case "/Lotus/Powersuits/Devourer/DevourerBaseSuit": -- Grendel
				build.powersuit.health.base += (rank + 2) // 3 * 10
				build.powersuit.health.base += (rank + 1) // 3 * 10
				build.powersuit.power.base += rank // 3 * 5
				break

			case "/Lotus/Powersuits/Infestation/InfestationBaseSuit": -- Nidus
				build.powersuit.health.base += (rank + 2) // 3 * 10
				build.powersuit.armor.base += (rank + 4) // 6 * 20
				build.powersuit.ability_strength.stacking_multiply_base += (rank + 3) // 6 * 0.03
				build.powersuit.power.base += rank // 6 * 10
				build.powersuit.heal_rate.base = 5
				build.powersuit.heal_rate.base += rank // 6 * 2
				break

			case "/Lotus/Powersuits/PaxDuviricus/PaxDuviricusBaseSuit": -- Kullervo
				build.powersuit.health.base += (rank + 2) // 3 * 20
				build.powersuit.armor.base += (rank + 1) // 3 * 10
				build.powersuit.power.base += rank // 3 * 5
				break

			case "/Lotus/Powersuits/IronFrame/IronFrameBaseSuit": -- Hildryn
				build.powersuit.health.base += (rank + 2) // 3 * 10
				build.powersuit.shield.base += (rank + 1) // 3 * 25
				build.powersuit.shield.base += rank // 3 * 25
				break

			case "/Lotus/Powersuits/BrokenFrame/BrokenFrameBaseSuit": -- Xaku
				build.powersuit.health.base += (rank + 2) // 3 * 9
				build.powersuit.shield.base += (rank + 1) // 3 * 9
				build.powersuit.power.base += rank // 3 * 7
				break

			case "/Lotus/Powersuits/Alchemist/AlchemistBaseSuit": -- Lavos
				build.powersuit.health.base += (rank + 2) // 3 * 20
				build.powersuit.shield.base += (rank + 1) // 3 * 10
				build.powersuit.armor.base += rank // 3 * 10
				break

			case "/Lotus/Powersuits/Berserker/BerserkerBaseSuit": -- Valkyr
				build.powersuit.health.base += (rank + 2) // 3 * 10
				build.powersuit.shield.base += (rank + 1) // 3 * 5
				build.powersuit.power.base += rank // 3 * 5
				break

			case "/Lotus/Powersuits/Pacifist/PacifistBaseSuit": -- Baruuk
			case "/Lotus/Powersuits/Garuda/GarudaBaseSuit": -- Garuda
			case "/Lotus/Powersuits/Wisp/WispBaseSuit": -- Wisp
			case "/Lotus/Powersuits/Yareli/YareliBaseSuit": -- Yareli
				build.powersuit.health.base += (rank + 2) // 3 * 10
				build.powersuit.shield.base += (rank + 1) // 3 * 10
				build.powersuit.power.base += rank // 3 * 10
				break

			default:
				build.powersuit.health.base += (rank + 2) // 3 * 10
				build.powersuit.shield.base += (rank + 1) // 3 * 10
				build.powersuit.power.base += rank // 3 * 5
		end
	end
	if inbuild.primary?.name then
		local pe_data = ExportWeapons[inbuild.primary.name]
		build.primary = {
			dmg_impact = { base = pe_data.damagePerShot[1] },
			dmg_puncture = { base = pe_data.damagePerShot[2] },
			dmg_slash = { base = pe_data.damagePerShot[3] },
			dmg_heat = { base = pe_data.damagePerShot[4] },
			dmg_cold = { base = pe_data.damagePerShot[5] },
			dmg_electricity = { base = pe_data.damagePerShot[6] },
			dmg_toxin = { base = pe_data.damagePerShot[7] },
			dmg_blast = { base = pe_data.damagePerShot[8] },
			dmg_radiation = { base = pe_data.damagePerShot[9] },
			dmg_gas = { base = pe_data.damagePerShot[10] },
			dmg_magnetic = { base = pe_data.damagePerShot[11] },
			dmg_viral = { base = pe_data.damagePerShot[12] },
			dmg_corrosive = { base = pe_data.damagePerShot[13] },
			crit_chance = { base = pe_data.criticalChance },
		}
	end
	if inbuild.secondary?.name then
		local pe_data = ExportWeapons[inbuild.secondary.name]
		build.secondary = {
			dmg_impact = { base = pe_data.damagePerShot[1] },
			dmg_puncture = { base = pe_data.damagePerShot[2] },
			dmg_slash = { base = pe_data.damagePerShot[3] },
			dmg_heat = { base = pe_data.damagePerShot[4] },
			dmg_cold = { base = pe_data.damagePerShot[5] },
			dmg_electricity = { base = pe_data.damagePerShot[6] },
			dmg_toxin = { base = pe_data.damagePerShot[7] },
			dmg_blast = { base = pe_data.damagePerShot[8] },
			dmg_radiation = { base = pe_data.damagePerShot[9] },
			dmg_gas = { base = pe_data.damagePerShot[10] },
			dmg_magnetic = { base = pe_data.damagePerShot[11] },
			dmg_viral = { base = pe_data.damagePerShot[12] },
			dmg_corrosive = { base = pe_data.damagePerShot[13] },
			crit_chance = { base = pe_data.criticalChance },
		}
	end
	if inbuild.melee?.name then
		local pe_data = ExportWeapons[inbuild.melee.name]
		build.melee = {
			dmg_impact = { base = pe_data.damagePerShot[1] },
			dmg_puncture = { base = pe_data.damagePerShot[2] },
			dmg_slash = { base = pe_data.damagePerShot[3] },
			dmg_heat = { base = pe_data.damagePerShot[4] },
			dmg_cold = { base = pe_data.damagePerShot[5] },
			dmg_electricity = { base = pe_data.damagePerShot[6] },
			dmg_toxin = { base = pe_data.damagePerShot[7] },
			dmg_blast = { base = pe_data.damagePerShot[8] },
			dmg_radiation = { base = pe_data.damagePerShot[9] },
			dmg_gas = { base = pe_data.damagePerShot[10] },
			dmg_magnetic = { base = pe_data.damagePerShot[11] },
			dmg_viral = { base = pe_data.damagePerShot[12] },
			dmg_corrosive = { base = pe_data.damagePerShot[13] },
			crit_chance = { base = pe_data.criticalChance },
			combo_duration = { base = pe_data.comboDuration },
		}
	end
	local sets = {}
	if inbuild.powersuit then
		if inbuild.powersuit.mods then
			local aura_mod
			for pairs(inbuild.powersuit.mods) as mod do
				local mod_data = (overframe_mods[mod.name] or error("Unknown mod: "..mod.name)).data
				local set_bonus = 1
				if mod_data.ModSetValues then
					local n = get_num_mods_from_set(inbuild.powersuit.mods, mod_data.ModSet)
					if n > 1 then
						set_bonus += mod_data.ModSetValues[n - 1]
					end
				elseif mod_data.ModSet then
					sets[mod_data.ModSet] = (sets[mod_data.ModSet] or 0) + 1
				end
				local value_multiplier = ((mod.rank or 0) + 1) * set_bonus
				if mod_data.ItemCompatibilityLocTag == "/Lotus/Language/Menu/CategoryAura" then
					-- Save aura mod for later so aura strength can be applied
					aura_mod = { data = mod_data, rank = mod.rank, mult = value_multiplier }
				else
					build_applyMod(build, "powersuit", mod_data, rank, value_multiplier)
				end
			end
			if aura_mod then
				build_applyMod(build, "powersuit", aura_mod.data, aura_mod.rank, aura_mod.mult * stat_getValue(build.powersuit.aura_strength) * stat_getValue(build.powersuit.aura_effectiveness))
			end
		end
		if build.powersuit then
			build.powersuit.aura_strength = nil
			build.powersuit.aura_effectiveness = nil
		end
	end
	if inbuild.primary?.mods then
		for pairs(inbuild.primary.mods) as mod do
			local mod_data = (overframe_mods[mod.name] or error("Unknown mod: "..mod.name)).data
			if mod_data.ModSet then
				sets[mod_data.ModSet] = (sets[mod_data.ModSet] or 0) + 1
			end
			build_applyMod(build, "primary", mod_data, mod.rank, (mod.rank or 0) + 1)
		end
	end
	if inbuild.secondary?.mods then
		for pairs(inbuild.secondary.mods) as mod do
			local mod_data = (overframe_mods[mod.name] or error("Unknown mod: "..mod.name)).data
			if mod_data.ModSet then
				sets[mod_data.ModSet] = (sets[mod_data.ModSet] or 0) + 1
			end
			build_applyMod(build, "secondary", mod_data, mod.rank, (mod.rank or 0) + 1)
		end
	end
	if inbuild.melee?.mods then
		for pairs(inbuild.melee.mods) as mod do
			local mod_data = (overframe_mods[mod.name] or error("Unknown mod: "..mod.name)).data
			local set_bonus = 1
			if mod_data.ModSetValues then
				local n = get_num_mods_from_set(inbuild.melee.mods, mod_data.ModSet)
				if n > 1 then
					set_bonus += mod_data.ModSetValues[n - 1]
				end
			elseif mod_data.ModSet then
				sets[mod_data.ModSet] = (sets[mod_data.ModSet] or 0) + 1
			end
			build_applyMod(build, "melee", mod_data, mod.rank, ((mod.rank or 0) + 1) * set_bonus)
		end
	end
	for set, n in pairs(sets) do
		build_applyMod(build, nil, overframe_modsets[set].data, n, n)
	end
	return build
end

export function build_getConditionals(build)
	local conditionals = {}
	for pairs(build) as gear do
		for pairs(gear) as stat do
			if stat.conditionals then
				for pairs(stat.conditionals) as conditional do
					if not conditionals[conditional.type] then
						conditionals[conditional.type] = {
							proc_chance = conditional.proc_chance,
							max_stacks = conditional.max_stacks
						}
					end
				end
			end
		end
	end
	return conditionals
end

export function build_applyConditionals(build, to_apply)
	local outbuild = {}
	for gear_name, gear in pairs(build) do
		outbuild[gear_name] = {}
		for stat_name, stat in pairs(gear) do
			outbuild[gear_name][stat_name] = stat_applyConditionals(stat, to_apply)
		end
	end
	if outbuild.powersuit then
		outbuild.powersuit.power_health = outbuild.powersuit.power * outbuild.powersuit.power_to_health_efficiency
		outbuild.powersuit.armor_damage_reduction = outbuild.powersuit.armor / (outbuild.powersuit.armor + 300)
		outbuild.powersuit.effective_health = outbuild.powersuit.health / (1 - outbuild.powersuit.armor_damage_reduction)
		outbuild.powersuit.effective_power_health = outbuild.powersuit.power_health / (1 - outbuild.powersuit.armor_damage_reduction)
		outbuild.powersuit.effective_health_incl_power = outbuild.powersuit.effective_health + outbuild.powersuit.effective_power_health
	end
	return outbuild
end

export function build_applyNoConditionals(build)
	return build_applyConditionals(build, {})
end

export function build_applyAllConditionals(build)
	local to_apply = {}
	for conditional_type, conditional in pairs(build_getConditionals(build)) do
		to_apply[conditional_type] = conditional.max_stacks
	end
	return build_applyConditionals(build, to_apply)
end

export function evaluate_build(build)
	return build_applyNoConditionals(parse_build(build))
end

-- Evaluation for damage against enemies (Experimental)

if not enemies then
	local cloned_flesh = {
		impact = -0.25,
		slash = 0.25,
		gas = -0.50,
		heat = 0.25,
		cloned_flesh = 0.75,
	}

	local ferrite_armor = {
		puncture = 0.50,
		slash = -0.15,
		blast = -0.25,
		viral = 0.75,
	}

	enemies = {
		["Lancer"] = {
			base_level = 1,
			health = cloned_flesh,
			armor = ferrite_armor,
			armor_points = 100,
		},
		["Heavy Gunner"] = {
			base_level = 8,
			health = cloned_flesh,
			armor = ferrite_armor,
			armor_points = 500,
		}
	}
end

local function level_scaling_trans(base_level, start, _end, level)
	if level - base_level < start then
		return 0
	end
	if level - base_level > _end then
		return 1
	end
	local T = (level - base_level - start) / (_end - start)
	return 3 * T ^ 2 - 2 * T ^ 3
end

local function enemy_getArmor(enemy, level)
	if level < enemy.base_level then
		level = enemy.base_level
	end
	local old_armor = 1 + 0.005 * (level - enemy.base_level) ^ 1.75
	local new_armor = 1 + 0.40 * (level - enemy.base_level) ^ 0.75
	local armor_mult = old_armor * (1 - level_scaling_trans(enemy.base_level, 70, 80, level)) + new_armor * level_scaling_trans(enemy.base_level, 70, 80, level)
	return enemy.armor_points * armor_mult
end

local function enemy_getEffectiveDamageOfType(enemy, level, damage_type, amount)
	local health_offset = enemy.health[damage_type] or 0
	local armor_offset = enemy.armor[damage_type] or 0
	local armor = enemy_getArmor(enemy, level)
	return amount * (1 + health_offset) * (1 + armor_offset) * 300 / (300 + armor * (1 - armor_offset))
end

export function enemy_getEffectiveDamage(enemy, level, gear)
	return enemy_getEffectiveDamageOfType(enemy, level, "impact", gear.dmg_impact)
		+ enemy_getEffectiveDamageOfType(enemy, level, "puncture", gear.dmg_puncture)
		+ enemy_getEffectiveDamageOfType(enemy, level, "slash", gear.dmg_slash)
		+ enemy_getEffectiveDamageOfType(enemy, level, "heat", gear.dmg_heat)
		+ enemy_getEffectiveDamageOfType(enemy, level, "cold", gear.dmg_cold)
		+ enemy_getEffectiveDamageOfType(enemy, level, "electricity", gear.dmg_electricity)
		+ enemy_getEffectiveDamageOfType(enemy, level, "toxin", gear.dmg_toxin)
		+ enemy_getEffectiveDamageOfType(enemy, level, "blast", gear.dmg_blast)
		+ enemy_getEffectiveDamageOfType(enemy, level, "radiation", gear.dmg_radiation)
		+ enemy_getEffectiveDamageOfType(enemy, level, "gas", gear.dmg_gas)
		+ enemy_getEffectiveDamageOfType(enemy, level, "magnetic", gear.dmg_magnetic)
		+ enemy_getEffectiveDamageOfType(enemy, level, "viral", gear.dmg_viral)
		+ enemy_getEffectiveDamageOfType(enemy, level, "corrosive", gear.dmg_corrosive)
end
