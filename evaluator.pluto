-- @pluto_warnings enable-non-portable-bytecode

local function readfile(path)
	local f <close> = io.open(path, "rb")
	return f:read("*a")
end

local json = require "pluto:json"

local ExportWarframes = json.decode(readfile("data/ExportWarframes_en.json")).ExportWarframes
local ExportWeapons = json.decode(readfile("data/ExportWeapons_en.json")).ExportWeapons
local overframe_mods = json.decode(readfile("data/overframe_mods.json"))

local function get_powersuit_data_from_public_export(uniqueName: string): ?table
	for ExportWarframes as item do
		if item.uniqueName == uniqueName then
			return item
		end
	end
	return nil
end

local function get_weapon_data_from_public_export(uniqueName: string): ?table
	for ExportWeapons as item do
		if item.uniqueName == uniqueName then
			return item
		end
	end
	return nil
end

local function get_num_mods_from_set(mods, set)
	local n = 0
	for mods as mod do
		if overframe_mods[mod.name].data.ModSet == set then
			++n
		end
	end
	return n
end

local function stat_addConditional(stat, conditional)
	if not stat.conditionals then
		stat.conditionals = {}
	end
	stat.conditionals[#stat.conditionals + 1] = conditional
end

local function stat_applyConditionals(stat, to_apply)
	local stacking_multiply_carry = stat.stacking_multiply_base or 1
	if stat.conditionals then
		for stat.conditionals as conditional do
			if to_apply[conditional.type] ~= nil then
				stacking_multiply_carry += conditional.value * to_apply[conditional.type]
			end
		end
	end
	return stat.base * stacking_multiply_carry
end

export function parse_build(build)
	local eval = {}
	if build.powersuit then
		local pe_data = get_powersuit_data_from_public_export(build.powersuit.name)
		eval.powersuit = {
			health = { base = pe_data.health },
			shield = { base = pe_data.shield },
			armor = { base = pe_data.armor },
			power = { base = pe_data.power },
		}

		local rank = build.powersuit.rank or 30
		switch pe_data.parentName do
			case "/Lotus/Powersuits/Sandman/SandmanBaseSuit": -- Inaros
			case "/Lotus/Powersuits/Devourer/DevourerBaseSuit": -- Grendel
				eval.powersuit.health.base += (rank + 2) // 3 * 10
				eval.powersuit.health.base += (rank + 1) // 3 * 10
				eval.powersuit.power.base += rank // 3 * 5
				break

			case "/Lotus/Powersuits/Infestation/InfestationBaseSuit": -- Nidus
				eval.powersuit.health.base += (rank + 2) // 3 * 10
				eval.powersuit.armor.base += (rank + 1) // 3 * 10
				eval.powersuit.power.base += rank // 3 * 5
				break

			case "/Lotus/Powersuits/PaxDuviricus/PaxDuviricusBaseSuit": -- Kullervo
				eval.powersuit.health.base += (rank + 2) // 3 * 20
				eval.powersuit.armor.base += (rank + 1) // 3 * 10
				eval.powersuit.power.base += rank // 3 * 5
				break

			case "/Lotus/Powersuits/IronFrame/IronFrameBaseSuit": -- Hildryn
				eval.powersuit.health.base += (rank + 2) // 3 * 10
				eval.powersuit.shield.base += (rank + 1) // 3 * 25
				eval.powersuit.shield.base += rank // 3 * 25
				break

			case "/Lotus/Powersuits/BrokenFrame/BrokenFrameBaseSuit": -- Xaku
				eval.powersuit.health.base += (rank + 2) // 3 * 9
				eval.powersuit.shield.base += (rank + 1) // 3 * 9
				eval.powersuit.power.base += rank // 3 * 7
				break

			case "/Lotus/Powersuits/Alchemist/AlchemistBaseSuit": -- Lavos
				eval.powersuit.health.base += (rank + 2) // 3 * 20
				eval.powersuit.shield.base += (rank + 1) // 3 * 10
				eval.powersuit.armor.base += rank // 3 * 10
				break

			case "/Lotus/Powersuits/Berserker/BerserkerBaseSuit": -- Valkyr
				eval.powersuit.health.base += (rank + 2) // 3 * 10
				eval.powersuit.shield.base += (rank + 1) // 3 * 5
				eval.powersuit.power.base += rank // 3 * 5
				break

			case "/Lotus/Powersuits/Pacifist/PacifistBaseSuit": -- Baruuk
			case "/Lotus/Powersuits/Garuda/GarudaBaseSuit": -- Garuda
			case "/Lotus/Powersuits/Wisp/WispBaseSuit": -- Wisp
			case "/Lotus/Powersuits/Yareli/YareliBaseSuit": -- Yareli
				eval.powersuit.health.base += (rank + 2) // 3 * 10
				eval.powersuit.shield.base += (rank + 1) // 3 * 10
				eval.powersuit.power.base += rank // 3 * 10
				break

			default:
				eval.powersuit.health.base += (rank + 2) // 3 * 10
				eval.powersuit.shield.base += (rank + 1) // 3 * 10
				eval.powersuit.power.base += rank // 3 * 5
		end

		if build.powersuit.mods then
			local upgrades = {}
			for build.powersuit.mods as mod do
				local mod_data = overframe_mods[mod.name].data
				local set_bonus = 1
				if mod_data.ModSetValues then
					local n = get_num_mods_from_set(build.powersuit.mods, mod_data.ModSet)
					set_bonus += mod_data.ModSetValues[n - 1]
				end
				for mod_data.Upgrades as upgrade do
					upgrades[upgrade.UpgradeType] = (upgrades[upgrade.UpgradeType] or 0) + upgrade.Value * (mod.rank ? mod.rank + 1 : 1) * set_bonus
				end
			end
			if upgrades.AVATAR_HEALTH_MAX then
				eval.powersuit.health.stacking_multiply_base = (eval.powersuit.health.stacking_multiply_base or 1) + upgrades.AVATAR_HEALTH_MAX
			end
			if upgrades.AVATAR_ARMOUR then
				eval.powersuit.armor.stacking_multiply_base = (eval.powersuit.armor.stacking_multiply_base or 1) + upgrades.AVATAR_ARMOUR
			end
		end
	end
	if build.melee then
		local pe_data = get_weapon_data_from_public_export(build.melee.name)
		eval.melee = {
			crit_chance = { base = pe_data.criticalChance },
		}
		for build.melee.mods as mod do
			local mod_data = overframe_mods[mod.name].data
			if mod_data.ConditionalUpgrades then
				for mod_data.Upgrades as upgrade do
					if upgrade.UpgradeType == "WEAPON_CRIT_CHANCE" then
						stat_addConditional(eval.melee.crit_chance, {
							type = mod_data.ConditionalUpgrades[1],
							max_stacks = mod_data.MaxConditionalStacks,
							operation = upgrade.OperationType,
							value = upgrade.Value * (mod.rank ? mod.rank + 1 : 1),
						})
					end
				end
			end
		end
	end
	return eval
end

export function build_getConditionals(build)
	local conditionals = {}
	for build as gear do
		for gear as stat do
			if stat.conditionals then
				for stat.conditionals as conditional do
					if not conditionals[conditional.type] then
						conditionals[conditional.type] = {
							max_stacks = conditional.max_stacks
						}
					end
				end
			end
		end
	end
	return conditionals
end

export function build_applyConditionals(build, to_apply)
	local flat_build = {}
	for gear_name, gear in build do
		flat_build[gear_name] = {}
		for stat_name, stat in gear do
			flat_build[gear_name][stat_name] = stat_applyConditionals(stat, to_apply)
		end
	end
	return flat_build
end

export function build_applyNoConditionals(build)
	return build_applyConditionals(build, {})
end

export function build_applyAllConditionals(build)
	local to_apply = {}
	for conditional_type, conditional in build_getConditionals(build) do
		to_apply[conditional_type] = conditional.max_stacks
	end
	return build_applyConditionals(build, to_apply)
end

export function evaluate_build(build)
	return build_applyNoConditionals(parse_build(build))
end

export function armor_to_damage_reduction(armor)
	return armor / (armor + 300)
end

export function calculate_effective_health(health, damage_reduction)
	return health / (1 - damage_reduction)
end
